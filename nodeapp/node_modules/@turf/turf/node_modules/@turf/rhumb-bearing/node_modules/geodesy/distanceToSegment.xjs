/**
 * Returns distance from ‘this’ point to great circle segment between point1 & point2.
 *
 * If this point is ‘within’ the extent of the segment, this is the cross-track distance; otherwise,
 * it is the distance to the closer endpoint.
 *
 * @param   {LatLon} point1 - Start point of great circle segment.
 * @param   {LatLon} point2 - End point of great circle segment.
 * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).
 * @returns {number} Distance to segment.
 *
 * @example
 *   var p1 = new LatLon(51.0, 1.0), p2 = new LatLon(51.0, 2.0);
 *
 *   var p = new LatLon(51.0, 1.9);
 *   var d = p.distanceToSegment(p1, p2);    // Number(d.toPrecision(4)): 42.71
 *
 *   var p = new LatLon(51.0, 2.1);
 *   var d = p.distanceToSegment(p1, p2);    // Number(d.toPrecision(4)):  6998
 *   var d = p.crossTrackDistanceTo(p1, p2); // Number(d.toPrecision(4)): -52.2
 */
LatLon.prototype.distanceToSegment = function(point1, point2, radius) {
    var v0 = this.toVector(), v1 = point1.toVector(), v2 = point2.toVector();

    // dot product p10⋅p12 tells us if p0 is on p2 side of p1, similarly for p20⋅p21
    var p10 = v0.minus(v1), p12 = v2.minus(v1);
    var p20 = v0.minus(v2), p21 = v1.minus(v2);

    var extent1 = p10.dot(p12);
    var extent2 = p20.dot(p21);

    var withinExtent = extent1>=0 && extent2>=0;

    if (withinExtent) {
        // closer to segment than to its endpoints, use cross-track distance
        var d = Math.abs(this.crossTrackDistanceTo(point1, point2, radius));
    } else {
        // beyond segment extent, take smaller of distances to endpoints
        var d1 = this.distanceTo(point1, radius);
        var d2 = this.distanceTo(point2, radius);
        var d = Math.min(d1, d2);
    }

    return d;
};

